model {
  
  mu_alpha ~ dbeta(1,1)T(0,.5)
  mu_beta ~ dbeta(1,1)T(0,.5)
  mu_gamma ~ dbeta(1,1)T(0,.5)
  mu_eta ~ dbeta(1,1)T(0,.5)
  
  lambda_alpha ~ dgamma(2.5/2,0.01/2)
  lambda_beta ~ dgamma(2.5/2,0.01/2)
  lambda_gamma ~ dgamma(2.5/2,0.01/2)
  lambda_eta ~ dgamma(2.5/2,0.01/2) 
  
  
  for (s in 1:nsubs) {
    
    alpha[s] ~ dnorm(mu_alpha, lambda_alpha)T(0,.5)
    beta[s] ~ dnorm(mu_beta, lambda_beta)T(0,.5)
    gamma[s] ~ dnorm(mu_gamma, lambda_gamma)T(0,.5)
    eta[s] ~ dnorm(mu_eta, lambda_eta)T(0,.5)
    
    P[1,1] <- 1
    
    P[1,2] <- 0
    
    P[1,3] <- 0
    
    P[1,4] <- 0
    
    
    
    P[2,1] <- alpha
    
    P[2,2] <- 1-alpha-beta
    
    P[2,3] <- beta
    
    P[2,4] <- 0
    
    
    
    P[3,1] <- 0
    
    P[3,2] <- gamma
    
    P[3,3] <- 1-gamma-eta
    
    P[3,4] <- eta
    
    
    
    P[4,1] <- 0
    
    P[4,2] <- 0
    
    P[4,3] <- 0
    
    P[4,4] <- 1
    
    
    
    state[s,1] ~ dcat(c(.25,.25,.25,.25))
    
    
    
    
    for (t in 2:ntrials[s]) {
      
      p[s,1:4,t] <- P[state[s,(t-1)],] # set p vector for rcat, depends in previous state
      
      state[s,t] ~ dcat(p[s,1:4,t]) #current state sampled from cat. dist.
      
      
      
      theta[s,t] <- ifelse(state[s,t]<3,0,1)
      
      
      X[s,t] ~ dbin(1,theta[s,t])
      
    }
    
    
    
  }                                    
    
    
    
  
}